#!/usr/bin/python
import numpy as np

import collections
import sys

import src.infile_handler as infile_handler
import src.raw_data as raw_data
import src.utils as utils
import src.wick as wick
import src.projection as projection
import src.subduction as subduction
import src.setup_gevp as setup_gevp
import src.plot as plot
import src.plot_bokeh as bokeh

import pandas as pd
from pandas import Series, DataFrame

from ast import literal_eval

################################################################################
if __name__ == '__main__':
    pd.set_option('display.width', None)
    # TODO: replace that by with statement
    try:

        ###########################################################################
        # Parameters ##############################################################

        args, config = infile_handler.get_parameters()

        verbose = args.verbose
        continuum_basis_string = args.basis

        # optional parameter, Default: False
        flag_pion = config.getboolean('parameters', 'Read pion')

        # Choices: ['rho', 'pipi']
        process = config.get('parameters', 'Process to analyse').lower()
        if process not in ['rho', 'pipi']:
            print 'Only analysis for "rho" and "pipi" are supported!'
            sys.exit(0)

        if verbose:
            print 80 * '#'
            print 'Reading infile'

        if verbose >= 2:
            print 'Reading data for pion: {}'.format(flag_pion)
            print 'Process to analyse: {}'.format(process)

        flag = {}
        flag['read'] = config.getboolean('parameters', 'Read rho')
        flag['subduce'] = config.getboolean('parameters', 'Subduce')
        flag['contract'] = config.getboolean('parameters', 'Contract')
        flag['create gevp'] = config.getboolean('parameters', 'Create Gevp')
        flag['plot'] = config.getboolean('parameters', 'Plot data')

        if verbose >= 2:
            print flag

        sta_cnfg = config.getint('gauge configuration numbers',
                     'First configuration')
        end_cnfg = config.getint('gauge configuration numbers',
                     'Last configuration')
        del_cnfg = config.getint('gauge configuration numbers',
                     'Configuration stepping')
        missing_configs = config.get('gauge configuration numbers',
                       'Missing configurations')
        # turns missing configs into list of integers
        if (missing_configs == ''):
            missing_configs = []
        else:
            missing_configs = [int(m) for m in missing_configs.split(',')]

        if verbose >= 2:
            print 'Reading configs', sta_cnfg, '-', end_cnfg, ' in steps of ', del_cnfg
            print 'Skipping ', missing_configs

        ensemble = config.get('ensemble parameters', 'Ensemble Name')
        T = config.getint('ensemble parameters', 'T')

        if verbose >= 2:
            print ensemble
            print T

        beta = config.get('phase conventions', 'beta')
        if verbose >= 2:
            print 'beta = ', beta

        p_cutoff = config.getint('gevp parameters', 'p_cutoff')
        p = config.get('gevp parameters', 'p_cm')
        p = [int(k) for k in p.split(',')]
        gamma_input = config.get('gevp parameters', 'Dirac structure')
        # translates list of names for gamma structures to indices used in
        # contraction code
        gamma_input = gamma_input.replace(" ", "").split(',')
        gamma_input = {0: ['gamma_5'], 1: gamma_input}

        if verbose >= 2:
            print 'p_cm = ', p
            print 'p_cutoff = ', p_cutoff
            print 'Gamma structures: ', gamma_input

        diagrams = config.get('contraction details', 'Diagram')
        diagrams = diagrams.replace(" ", "").split(',')
        directories = config.get('contraction details', 'Input Path')
        directories = directories.replace(" ", "").replace("\n", "")
        directories = directories.split(',')

        if verbose >= 2:
            print 'Wick diagrams to subduce: ', diagrams
        # use the same directory for all diagrams if only one is given
        if (len(directories) == 1):
            directories = directories * len(diagrams)
        if verbose >= 2:
            for i in range(len(diagrams)):
                print 'Read data for ', diagrams[i], ' from ', directories[i]

        path_to_sc = config.get('Environment details',
                    'Path to one-meson subduction coefficients')
        path_to_sc_2 = config.get('Environment details',
                    'Path to two-meson subduction coefficients')

        outpath = config.get('Environment details', 'Output Path')

        if verbose >= 2:
            print 'Subduction coefficients will be read from ', path_to_sc
            print 'Two-particle projection coefficients will be read from ', path_to_sc_2
            print 'Data will be writen to', outpath

        plot_p_and_g = config.getboolean('plot details', 'Plot correlators')
        plot_pcm_and_mu = config.getboolean('plot details', 'Plot p_cm and row')
        plot_avg = config.getboolean('plot details', 'Plot average')

        plot_experimental = config.getboolean('plot details', 'Plot experimental')

        logscale = config.getboolean('plot details', 'Logscale')

        bootstrapsize = config.getint('plot details', 'Number of bootstrap samples')

        if verbose >= 2:
            if plot_p_and_g:
                print 'Plotting correlators for all momenta and Dirac structures'
            if plot_pcm_and_mu:
                print 'Plotting correlators for all p_cm_and_mu'
            print 'Logscale: ', logscale

        ############################################################################
        # Main
        # TODO: pull out irrep as outer loop and do not use it in any of the files
        # TODO: refactor towards a more objectoriented design
        for p_cm in p:
            if verbose:
                print 80 * '#'
                print 'p_cm = ', p_cm

            ########################################################################
            # read diagrams for correlators contributing to rho
            if flag['read']:
                path = '%s/%s/0_raw-data/' % (outpath, ensemble)
                raw_data.read(path, T, diagrams, directories, sta_cnfg, end_cnfg, del_cnfg,
                        missing_configs, process, p_cm, p_cutoff, gamma_input, verbose)

            # TODO: Is gamma_input giving the right quantum numbers?
            if flag_pion:
                path = '%s/%s/0_raw-data/' % (outpath, ensemble)
                raw_data.read(path, T, ['C2c'], directories[:1], sta_cnfg, end_cnfg, del_cnfg,
                        missing_configs, process, p_cm, p_cutoff, gamma_input, verbose)

                pion_data = utils.read_hdf5_correlators(path + 'C2c_p%1i.h5' % p_cm, 'data')
                path = '%s/%s/3_gevp-data/' % (outpath, ensemble)
                filename = 'pi_p%1i.dat' % (p_cm)
                utils.write_ascii_correlators(
                  path, filename, pion_data.mean(axis=1).apply(np.real), verbose)


            ########################################################################
            # Setup of list of pcm and irrep to loop over
            path = '%s/%s/0_raw-data/' % (outpath, ensemble)
            filename = '%s_p%1i_qn.h5' % (diagrams[0], p_cm)
            lookup_qn = utils.read_hdf5_correlators(path + filename, 'qn')

            # Angular momentum for particles of interest
            if process == 'rho':
                j = 1
            elif process == 'pipi':
                j = 0

            # helper function to read all subduced data from disk
            list_of_pcm = lookup_qn['p_{cm}'].unique()
            list_of_irreps = projection.get_list_of_irreps(list_of_pcm, path_to_sc, j)
            correlators = wick.set_lookup_correlators(diagrams)


            ########################################################################
            # Subduction

            # Introduce named tuple to identify quark line diagram and irreducible
            # representation of little group it transforms under
            ContractionType = collections.namedtuple('ContractionType',
                                 ['diagram', 'irrep'])

            for irrep in list_of_irreps:
                print '\t  Subducing into %s' % irrep

                contracted_data_avg = {}
                for correlator, diagrams in correlators.iteritems():

                    subduced_data = {}
                    for diagram in diagrams:

                        if flag['subduce']:
                            print '\tSubducing data for %s' % diagram

                            lattice_operators = projection.project(j, correlator, 
                                    continuum_basis_string, gamma_input, list_of_pcm, 
                                    path_to_sc, path_to_sc_2, verbose)
                            lattice_operators = lattice_operators.xs(beta, level=r'\beta')

                            path = '%s/%s/0_raw-data/' % (outpath, ensemble)
                            filename = '%s_p%1i.h5' % (diagram, p_cm)
                            data = utils.read_hdf5_correlators(path + filename, 'data')
                            filename = '%s_p%1i_qn.h5' % (diagram, p_cm)
                            lookup_qn = utils.read_hdf5_correlators(path + filename, 'qn')

                            lookup_corr = subduction.set_lookup_corr(
                              lattice_operators, lookup_qn, verbose)

                            subduced_data[diagram] = subduction.project_correlators(data, lookup_corr)
                            del data

                            # write data to disc
                            path = '%s/%s/1_subduced-data/' % (outpath, ensemble)

                            filename = '/%s_p%1i_%s.h5' % (diagram, p_cm, irrep)
                            utils.write_hdf5_correlators(
                              path, filename, subduced_data[diagram], 'data', verbose)

                            lattice_operators.sort_index().\
                                reset_index(["operator_label_{so}", "operator_label_{si}"],
                                    drop=True).\
                                to_csv(path+"lattice-operators_{}_p{}_{}.tsv".format(
                                    diagram, p_cm, irrep), sep="\t")

                        elif flag['contract']:

                            path = '%s/%s/1_subduced-data/' % (outpath, ensemble)

                            filename = '/%s_p%1i_%s.h5' % (diagram, p_cm, irrep)
                            subduced_data[diagram] = utils.read_hdf5_correlators(
                              path + filename, 'data')

                ############################################################################
                # Wick contraction

                    if flag['contract']:
                        print '\tContracting data for %s' % correlator
                        ci = ContractionType(correlator, irrep)

                        if process == 'rho':
                            # rho analysis
                            contracted_data = wick.rho(
                              subduced_data, correlator, verbose)
                        elif process == 'pipi':
                            # pipi I=2 analysis
                            contracted_data = wick.pipi(
                              subduced_data, correlator, verbose)
                        del subduced_data

                        # write data to disc
                        path = '%s/%s/2_contracted-data/' % (outpath, ensemble)
                        filename = '/%s_p%1i_%s.h5' % (correlator, p_cm, irrep)
                        utils.write_hdf5_correlators(
                          path, filename, contracted_data, 'data', verbose)

                    elif (flag['create gevp'] or flag['plot']):

                        path = '%s/%s/2_contracted-data/' % (outpath, ensemble)

                        filename = '/%s_p%1i_%s.h5' % (correlator, p_cm, irrep)
                        contracted_data = \
                          utils.read_hdf5_correlators(path+filename, 'data')

                    # Only real part is physically relevant at that point
                    contracted_data_avg[ci] = contracted_data.apply(
                      np.real)

                    gevp_labels = ['Irrep', 'mult', 'gevp_row', 'gevp_col']
                    momentum_labels = \
                      [col for col in contracted_data_avg[ci].columns if 'p^{' in col]
                    gamma_labels = \
                      [col for col in contracted_data_avg[ci].columns if 'gamma' in col]

                    # sum over gamma structures.
                    contracted_data_avg[ci] = contracted_data_avg[ci].sum(
                      level=gevp_labels + ['p_{cm}'] + ['\mu'] + momentum_labels)
                    # sum over equivalent momenta
                    contracted_data_avg[ci] = contracted_data_avg[ci].sum(
                      level=gevp_labels + ['p_{cm}'] + ['\mu'])
                    # average over rows.
                    contracted_data_avg[ci] = contracted_data_avg[ci].mean(
                      level=gevp_labels + ['p_{cm}'])
                    # average over p_cm.
                    contracted_data_avg[ci] = contracted_data_avg[ci].mean(
                      level=gevp_labels)

                ########################################################################
                # Plotting

                    if flag['contract'] and flag['plot']:

                        if verbose:
                            print "Plotting data for ", irrep

                        path = '%s/%s/4_plots/p%1i/%s/' % (outpath, ensemble, p_cm,
                                           irrep)

                        # Select irrep and discard imaginary part (noise)
                        # :warning: multiplicity 1 hardcoded
                        plotdata = contracted_data.xs(
                          (irrep, 1), level=('Irrep', 'mult')).apply(np.real)

                        gevp_labels = ['gevp_row', 'gevp_col']
                        momentum_labels = \
                          [col for col in plotdata.index.names if 'p^{' in col]
                        gamma_labels = \
                          [col for col in plotdata.index.names if 'gamma' in col]

                        if plot_experimental:

                            # sum over equivalent momenta
                            plotdata_tmp = plotdata.copy()

                            filename = './%s_p%1i_%s_gammas_%s.html' % (
                              correlator, p_cm, irrep, continuum_basis_string)
                            bokeh.experimental(plotdata_tmp, correlator, bootstrapsize,
                              filename, logscale, verbose)

                        if plot_avg:
                            # sum over momenta and gamma structures
                            plotdata_tmp = plotdata.xs(beta, level=r'\beta')
                            plotdata_tmp = plotdata_tmp.sum(
                              level=gevp_labels + ['p_{cm}', '\mu'])
                            plotdata_tmp = plotdata_tmp.mean(level=gevp_labels)

                            filename = '/%s_p%1i_%s_avg_%s.pdf' % (
                              correlator, p_cm, irrep, continuum_basis_string)
                            pdfplot = utils.create_pdfplot(path, filename)
                            plot.for_each_gevp_element(plot.average, plotdata_tmp,
                                bootstrapsize, pdfplot, logscale, verbose)
                            pdfplot.close()


                        if plot_pcm_and_mu:
                            # sum over momenta and gamma structures
                            plotdata_tmp = plotdata.xs(beta, level=r'\beta')
                            plotdata_tmp = plotdata_tmp.sum(
                              level=gevp_labels + ['p_{cm}', '\mu'])

                            filename = '/%s_p%1i_%s_pcm-and-mu_%s.pdf' % (
                              correlator, p_cm, irrep, continuum_basis_string)
                            pdfplot = utils.create_pdfplot(path, filename)
                            plot.for_each_gevp_element(plot.pcm_and_mu, plotdata_tmp,
                                bootstrapsize, pdfplot, logscale, verbose)
                            pdfplot.close()

                        if plot_p_and_g:
                            # Want to look at all individual contributions
                            # Todo: Want to have imaginary part as well
                            plotdata_tmp = contracted_data.xs(
                                (irrep, 1), level=('Irrep', 'mult'))
                            plotdata_tmp = plotdata_tmp.xs(beta, level=r'\beta')
                            filename = '/%s_p%1i_%s_gammas_%s.pdf' % (
                              correlator, p_cm, irrep, continuum_basis_string)
                            pdfplot = utils.create_pdfplot(path, filename)
                            plot.p_and_gammas(plotdata_tmp, correlator, bootstrapsize,
                                  pdfplot, logscale, verbose)
                            pdfplot.close()


                ########################################################################
                # Gevp construction

                if flag['create gevp']:
                    print '\tCreating gevp'

                    gevp_data = setup_gevp.build_gevp(contracted_data_avg, process,
                                      irrep, verbose)

                    gevp_data = gevp_data.xs((irrep, 1), level=('Irrep', 'mult'))

                    path = '%s/%s/3_gevp-data/' % (outpath, ensemble)
                    filename = '%s_p%1i_%s_%d.h5' % (process, p_cm, irrep, 1)
                    utils.write_hdf5_correlators(path, filename, gevp_data, 'data', verbose)


#               path = '%s/%s/3_gevp-data/p%1i/%s/%s/' % (outpath, ensemble,
#                                   p_cm, irrep, tirr)
#               utils.write_ascii_gevp(path, process, select, verbose)

#             for tirr, select in gevp_data.groupby(level=[0]):
#
#               #print(select)
#               path = '%s/%s/3_gevp-data/' % (outpath, ensemble)
#               filename = '%s_p%1i_%s_%s.h5' % (process, p_cm, irrep, tirr)
#               utils.write_hdf5_correlators(path, filename, select, 'data',
#                            verbose)
#
#               path = '%s/%s/3_gevp-data/p%1i/%s/%s/' % (outpath, ensemble,
#                                   p_cm, irrep, tirr)
#               utils.write_ascii_gevp(path, process, select, verbose)

                ########################################################################
                # Plotting

                if flag['create gevp'] and flag['plot']:

                    if verbose:
                        print "Plotting Gevp data for ", irrep

                    path = '%s/%s/4_plots/p%1i/%s/' % (outpath, ensemble, p_cm, irrep)

                    if plot_avg:
                        filename = 'Gevp_p%1d_%s_avg.pdf' % (p_cm, irrep)
                        pdfplot = utils.create_pdfplot(path, filename)
                        plot.gevp(plot.average, gevp_data, bootstrapsize, pdfplot,
                            logscale, verbose)
                        pdfplot.close()
    
                    if plot_pcm_and_mu:
    #                 for p_cm_vec in list_of_pcm:
                        filename = 'Gevp_p%1d_%s_pcm-and-mu.pdf' % (p_cm, irrep)
                        pdfplot = utils.create_pdfplot(path, filename)
                        plot.gevp(plot.pcm_and_mu, gevp_data, bootstrapsize, pdfplot,
                            logscale, verbose)
                        pdfplot.close()
    

#                     for p_cm_vec in list_of_pcm:
#                     filename = 'Gevp_p001_%s.pdf' % (irrep)
#                     pdfplot = utils.create_pdfplot(path, filename)
#                     plot.gevp(plot.pcm_and_mu, gevp_data.xs(str((0,0,1)), level="p_{cm}", drop_level=False), bootstrapsize, pdfplot,
#                         logscale, verbose)
#                     pdfplot.close()

    except KeyboardInterrupt:
        pass
